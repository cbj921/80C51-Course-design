C51 COMPILER V9.01   MAIN                                                                  01/05/2020 18:55:34 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <reg52.h>
   2          #include "delay.h"
   3          #include "buzzer.h"
   4          #include "digitalTube.h"
   5          #include "timer.h"
   6          #include "key.h"
   7          #include "led.h"
   8          #include "uart.h"
   9          // 注意事项，使用串口时一定要勾选 “发送新行” 否则出错；设置闹钟要将 “请于” 删除，直接以年份开头
  10          //unsigned int test=0;
  11          // 闹钟日期的变量
  12          unsigned int alarmYear=0;
  13          unsigned char alarmMonth=0,alarmDay=0,alarmHour=0,alarmMinute=0; 
  14          unsigned char alarmFlag = 0; // 闹钟标志位 0：关闭  1：开启
  15          
  16          unsigned char monthDay[] = {31,28,31,30,31,30,31,31,30,31,30,31}; // 二月暂时按平年算
  17          unsigned char getData;
  18          unsigned char sdat[64]={0x00};        // 数据缓存区
  19          unsigned char sendDat[16]={0x00};     // 发送数据缓冲区
  20          unsigned char sendIndex = 0;         // 发送缓冲区指针
  21          unsigned char sp=0;   // 数据缓存区指针
  22          
  23          unsigned char buzzerKeyFlag = 0;
  24          unsigned char keyFlag=0;
  25          unsigned char countSecond = 0; // 用来计数3秒
  26          unsigned char ledTime = 0;
  27          
  28          // 通过中断来更新以下数据
  29          unsigned char hour=0,minute=0,second=0,month=1,day=21,week = 0;
  30          unsigned int year=2020; 
  31          unsigned char T0Num = 0;
  32          unsigned char modeFlag = 0; // 0：显示分秒 1：显示公元年  2：显示月日
  33          
  34          void updateTimeData();
  35          void showTime_MS();
  36          void showTime_Year();
  37          void stayThreeSecond();
  38          void showTime_MonthDay();
  39          void showWeekLed();
  40          unsigned char getWeek(unsigned int tYear,unsigned char tMonth,unsigned char tDay);
  41          void dealData(unsigned char *dataGo);
  42          unsigned char getTimeFromData(unsigned char *dataGo);
  43          void clearSDAT();
  44          unsigned char judgeLeapOrOrdinaryYear(unsigned int tYear);
  45          unsigned char getMonthDay(unsigned char tYear,unsigned char tMonth);
  46          unsigned char getSDATLength(unsigned char *point);
  47          void analyChar(unsigned char *point,unsigned char length);
  48          unsigned int getYearFromQuestion(unsigned char *point);
  49          void sendData(unsigned char *point);
  50          unsigned char getMonthFromQuestion(unsigned char *point);
  51          unsigned char getWorkDayFromMonth(unsigned int yearGo,unsigned char monthGo);
  52          void setAlarmClock(unsigned int yearGo,unsigned char monthGo,unsigned char dayGo,unsigned char hourGo,unsi
             -gned char minuteGo);
  53          void checkAlarmTime();
  54          void sendAllSDAT();
C51 COMPILER V9.01   MAIN                                                                  01/05/2020 18:55:34 PAGE 2   

  55          
  56          int main()
  57          {
  58   1              // init，各项功能初始化
  59   1              timerInit_0();           // 初始化计时器0
  60   1              uart_init();             // 初始化串口
  61   1              week = getWeek(year,month,day);          // 初始化星期
  62   1              showWeekLed();           // 显示LED
  63   1              clearSDAT();             // 清空缓冲区
  64   1              ///////////////////////
  65   1              while(1)
  66   1              {       
  67   2                      updateTimeData();   // 更新时间数据
  68   2                      modeFlag = checkKey_s1(&keyFlag,modeFlag); // 检测按键 S1
  69   2                      modeFlag = checkKey_s2(&keyFlag,modeFlag); // 检测按键 S2
  70   2                      closeBuzzer_s3(&buzzerKeyFlag,&alarmFlag);                         // 检测按键 S3，若按下，则关闭蜂鸣器
  71   2                      switch(modeFlag){
  72   3                              case 0: showTime_MS(); break;
  73   3                              case 1: showTime_Year(); break;
  74   3                              case 2: showTime_MonthDay(); break;
  75   3                      }       
  76   2              }
  77   1              return 0;
  78   1      }
  79          
  80          // 定时器T0中断函数
  81          void T0_func(void) interrupt 1
  82          {
  83   1              // T0为50ms溢出一次
  84   1              // 重装计数器
  85   1              TH0 = 0x3c;                                     //装定时初值高8位
  86   1              TL0 = 0xb0;                                     //装定时初值低8位
  87   1              T0Num++;
  88   1              if(T0Num == 20)
  89   1              {
  90   2                      T0Num = 0;
  91   2                      second++;
  92   2                      showWeekLed();             // 让LED灯显示并循环
  93   2              }
  94   1              stayThreeSecond();             // 三秒计数器    
  95   1      }
  96          // 更新时间数据
  97          void updateTimeData()
  98          {
  99   1              if(second >=60)
 100   1              {
 101   2                      second = 0;
 102   2                      minute ++;
 103   2                      if(alarmFlag)
 104   2                      {
 105   3                              checkAlarmTime(); // 检测闹钟   
 106   3                      }
 107   2              }
 108   1              if(minute >= 60)
 109   1              {
 110   2                      minute = 0;
 111   2                      hour ++;
 112   2              }
 113   1              if(hour >= 24)
 114   1              {
 115   2                      hour = 0;
 116   2                      day++;
C51 COMPILER V9.01   MAIN                                                                  01/05/2020 18:55:34 PAGE 3   

 117   2                      week = getWeek(year,month,day);          //更新星期
 118   2              }
 119   1              if(day > getMonthDay(year,month))
 120   1              {
 121   2                      day = 1;
 122   2                      month++;        
 123   2              }
 124   1              if(month > 12)
 125   1              {
 126   2                      month = 1;
 127   2                      year++;
 128   2              }
 129   1      }
 130          // 显示分秒的函数
 131          void showTime_MS()
 132          {
 133   1              unsigned char m1,m2,s1,s2;
 134   1              m2 = minute %10; // 分钟个位
 135   1              m1 = minute /10; // 分钟十位
 136   1              s2 = second %10; // 秒个位
 137   1              s1 = second /10; //     秒十位
 138   1              showFourNum(m1,m2,s1,s2,1);
 139   1      }
 140          // 显示公元年
 141          void showTime_Year()
 142          {
 143   1              unsigned char y1,y2,y3,y4;
 144   1              unsigned int tempYear = year;
 145   1              y4 = tempYear %10;
 146   1              tempYear = tempYear/10;
 147   1              y3 = tempYear %10;
 148   1              tempYear = tempYear/10;
 149   1              y2 = tempYear %10;
 150   1              tempYear = tempYear/10;
 151   1              y1 = tempYear %10;
 152   1              showFourNum(y1,y2,y3,y4,0);
 153   1      }
 154          // 显示月日
 155          void showTime_MonthDay()
 156          {
 157   1              unsigned char m1,m2,d1,d2;
 158   1              m2 = month %10;
 159   1              m1 = month /10;
 160   1              d2 = day %10;
 161   1              d1 = day /10;
 162   1              showFourNum(m1,m2,d1,d2,1);     
 163   1      }
 164          // 显示三秒的等待函数
 165          void stayThreeSecond()
 166          {
 167   1              if(keyFlag == 1)
 168   1              {
 169   2                      countSecond ++;
 170   2                      if(countSecond == 60)
 171   2                      {
 172   3                              keyFlag = 0;
 173   3                              modeFlag = 0;
 174   3                              countSecond = 0;
 175   3                      }
 176   2              }
 177   1      }
 178          // 计算星期函数
C51 COMPILER V9.01   MAIN                                                                  01/05/2020 18:55:34 PAGE 4   

 179          unsigned char getWeek(unsigned int tYear,unsigned char tMonth,unsigned char tDay)
 180          {
 181   1              unsigned char topTwoYear ;              // 年份前两位(默认年份四位数)
 182   1              unsigned char lastTwoYear ;             // 年份后两位
 183   1              unsigned char dayGo = tDay;                             // 日
 184   1              unsigned char monthGo = tMonth;             // 3<=monthGo<=14,即1，2月当作前年的13，14月
 185   1              unsigned char weekGo;
 186   1      
 187   1              if(monthGo<3)
 188   1              {
 189   2                      if(monthGo == 1) monthGo = 13;
 190   2                      else if(monthGo == 2) monthGo = 14;
 191   2                      tYear --; 
 192   2              }
 193   1              topTwoYear = tYear/100;
 194   1              lastTwoYear = tYear%100;
 195   1              weekGo = ((topTwoYear/4)-2*topTwoYear+lastTwoYear+(lastTwoYear/4)+((13*(monthGo+1))/5)+dayGo-1)%7;
 196   1              return weekGo;
 197   1      }
 198          // led显示函数和蜂鸣器鸣叫
 199          void showWeekLed()
 200          {
 201   1              if(week !=0)
 202   1              {
 203   2                      week = getWeek(year,month,day);
 204   2                      showLed(week,ledTime%8);
 205   2                      ledTime++;      
 206   2              }
 207   1              else
 208   1              {
 209   2                      clearAllLed();
 210   2                      buzzer_reverse();       // 太吵了暂时注释
 211   2              }
 212   1      }
 213          
 214          // 串口中断函数
 215          void uart_func(void) interrupt 4
 216          {
 217   1              unsigned char length;
 218   1              // 接收数据
 219   1              if(RI)
 220   1              {
 221   2                      // 一个数字或者英文字符 占用 一个字节
 222   2                      // 一个汉字占用     两个字节
 223   2                      RI = 0;
 224   2                      getData = SBUF;
 225   2                      sdat[sp] = getData;
 226   2                      sp++;
 227   2                      if(sp>=64) sp = 0;
 228   2                      if(getData == 0x0A)
 229   2                      {
 230   3                              // 0x0A为结束标志位
 231   3                              // 通过判断数组中有效长度来判断是校准还是答题模式
 232   3                              length = getSDATLength(sdat);
 233   3                              if(length == 19)
 234   3                              {
 235   4                                      // 进行数据处理，赋值为对应的变量
 236   4                                      dealData(sdat); 
 237   4                              }  
 238   3                              else
 239   3                              {
 240   4                                      // 进行字符分析，给出答案
C51 COMPILER V9.01   MAIN                                                                  01/05/2020 18:55:34 PAGE 5   

 241   4                                      analyChar(sdat,length);
 242   4                                      sendData(sendDat);      
 243   4                              } 
 244   3                              // test：发送数据缓冲区全部内容
 245   3                              //sendAllSDAT();
 246   3                              // 清空sdat缓冲区，sp清零
 247   3                              clearSDAT();
 248   3                              sp = 0;
 249   3                      }
 250   2                      //SBUF = getData;
 251   2                      //test
 252   2              }
 253   1              if(TI)
 254   1              {
 255   2                      //TI =0;
 256   2              }
 257   1      }
 258          // 处理接收来的数据
 259          void dealData(unsigned char *dataGo)
 260          {
 261   1              unsigned char timeFlag = 0;  // 处理时间的标志位，0：年，1：月，2：日，以此类推
 262   1              unsigned char temp=0,i;
 263   1              // 将原时间数据都清零
 264   1              year = 0,month = 0,day = 0,hour = 0,minute = 0,second = 0;
 265   1      
 266   1              while(*dataGo != 0x0D)
 267   1              {
 268   2                      // 处理日期数据
 269   2                      if(*dataGo == 0x2F || *dataGo == 0x3A ||*dataGo == 0x2D) // 因为斜杆和冒号的十六进制为 0x2f和0x3a
 270   2                      {
 271   3                              timeFlag++;     
 272   3                              dataGo++;
 273   3                      }
 274   2                      switch(timeFlag){
 275   3                              case 0:
 276   3                                      for(i=0;i<4;i++)
 277   3                                      {
 278   4                                              temp = *dataGo - 0x30;
 279   4                                              year *= 10;
 280   4                                              year += temp;
 281   4                                              dataGo++; 
 282   4                                      }
 283   3                                      break;
 284   3                              case 1:
 285   3                                      month = getTimeFromData(dataGo); // 因为参数只是传值，不会改变真正的datago地址
 286   3                                      dataGo += 2;                                     // 所以我们要在函数外面再自增 2 才行
 287   3                                      break;
 288   3                              case 2:
 289   3                                      day = getTimeFromData(dataGo);
 290   3                                      dataGo += 2;
 291   3                                      break;
 292   3                              case 3:
 293   3                                      hour = getTimeFromData(dataGo);
 294   3                                      dataGo += 2;
 295   3                                      break;
 296   3                              case 4:
 297   3                                      minute = getTimeFromData(dataGo);
 298   3                                      dataGo += 2;
 299   3                                      break;
 300   3                              case 5:
 301   3                                      second = getTimeFromData(dataGo);
 302   3                                      dataGo += 2;
C51 COMPILER V9.01   MAIN                                                                  01/05/2020 18:55:34 PAGE 6   

 303   3                                      break;
 304   3                      }       
 305   2              }                               
 306   1      }
 307          // 计算月日时分秒的函数
 308          unsigned char getTimeFromData(unsigned char *point)
 309          {
 310   1              unsigned char temp=0,i;
 311   1              unsigned char returnValue=0;
 312   1              for(i=0;i<2;i++)
 313   1              {
 314   2                      temp = *point - 0x30;
 315   2                      returnValue *= 10;
 316   2                      returnValue += temp;
 317   2                      point++;
 318   2              }
 319   1              return returnValue; 
 320   1      }
 321          // 清空缓冲区
 322          void clearSDAT()
 323          {
 324   1              unsigned char i;
 325   1              for(i=0;i<64;i++)
 326   1              {
 327   2                      sdat[i] = 0x00;
 328   2              }
 329   1      }
 330          // 判断平润年
 331          unsigned char judgeLeapOrOrdinaryYear(unsigned int tYear)
 332          {
 333   1              unsigned int tempYear = tYear;
 334   1              if((tempYear%4 == 0 && tempYear%100 !=0)||(tempYear%100 == 0 && tempYear%400==0))
 335   1              {
 336   2                      return 1;       
 337   2              }
 338   1              return 0;
 339   1      }
 340          // 得到相应月份有几天
 341          unsigned char getMonthDay(unsigned char tYear,unsigned char tMonth)
 342          {
 343   1              if(tMonth == 2)
 344   1              {
 345   2                      if(judgeLeapOrOrdinaryYear(tYear))
 346   2                      {
 347   3                              return 29;
 348   3                      }
 349   2              }
 350   1              return monthDay[tMonth-1];              
 351   1      }
 352          // 获得SDAT中有效数据长度
 353          unsigned char getSDATLength(unsigned char *point)
 354          {
 355   1              unsigned char i=0;
 356   1              for(i=0;*point != 0x0D;)
 357   1              {
 358   2                      i++;
 359   2                      point++;        
 360   2              }
 361   1              return i;
 362   1      }
 363          // 字符分析
 364          void analyChar(unsigned char *point,unsigned char length)
C51 COMPILER V9.01   MAIN                                                                  01/05/2020 18:55:34 PAGE 7   

 365          {
 366   1              unsigned int tempYear=0;
 367   1              unsigned char tempMonth=0,tempDay=0,tempWeek=0;
 368   1              unsigned char tempHour=0,tempMinute=0;
 369   1      
 370   1              tempYear = getYearFromQuestion(point); // 获得年份
 371   1              if(length == 16)
 372   1              {
 373   2                      // 回答是否为闰年
 374   2                      if(judgeLeapOrOrdinaryYear(tempYear))
 375   2                      {
 376   3                              sendDat[0] = 0xCA;
 377   3                              sendDat[1] = 0xC7;
 378   3                      }
 379   2                      else
 380   2                      {
 381   3                              sendDat[0] = 0xB7;
 382   3                              sendDat[1] = 0xF1;
 383   3                      }
 384   2                      sendDat[2] = 0x0D;
 385   2                      sendDat[3] = 0x0A; // 回车
 386   2                      sendDat[4] = 0x3A; // 0x3A为结束标志位
 387   2              }
 388   1              else if(length == 24)
 389   1              {
 390   2                      // 回答是星期几
 391   2                      tempMonth = getTimeFromData(&point[6]); // 获得月份
 392   2                      tempDay = getTimeFromData(&point[10]); // 获得日
 393   2                      tempWeek = getWeek(tempYear,tempMonth,tempDay);
 394   2                      sendDat[0] = 0xD0;
 395   2                      sendDat[1] = 0xC7; // 星
 396   2                      sendDat[2] = 0xC6;
 397   2                      sendDat[3] = 0xDA; // 期
 398   2                      sendDat[4] = tempWeek + 0x30;
 399   2                      sendDat[5] = 0x0D;
 400   2                      sendDat[6] = 0x0A; // 回车
 401   2                      sendDat[7] = 0x3A; // 0x3A为结束标志位          
 402   2              }
 403   1              else if(length == 22)
 404   1              {
 405   2                      // 该问题少一个问号，为回答有几个工作日
 406   2                      tempMonth = getTimeFromData(&point[6]); // 获得月份
 407   2                      tempDay   = getWorkDayFromMonth(tempYear,tempMonth); // 这里用tempDay作为工作日的变量
 408   2                      sendDat[0] = (tempDay /10) +0x30;
 409   2                      sendDat[1] = (tempDay %10) +0x30;
 410   2                      sendDat[2] = 0xCC;
 411   2                      sendDat[3] = 0xEC; // “天”
 412   2                      sendDat[4] = 0x0D;
 413   2                      sendDat[5] = 0x0A; // 回车
 414   2                      sendDat[6] = 0x3A;  // 0x3A为结束标志位 
 415   2              }
 416   1              else if(length == 42) 
 417   1              {
 418   2                      // 即拓展4，闹钟功能。
 419   2                      // 要将 “请于” 删掉，直接从年份开始
 420   2                      tempMonth = getTimeFromData(&point[6]); // 获得月份      
 421   2                      tempDay = getTimeFromData(&point[10]); // 获得日
 422   2                      tempHour = getTimeFromData(&point[14]); // 获得小时
 423   2                      tempMinute = getTimeFromData(&point[18]); // 获得分钟
 424   2                      // 设置定时闹钟
 425   2                      setAlarmClock(tempYear,tempMonth,tempDay,tempHour,tempMinute);
 426   2                      //test
C51 COMPILER V9.01   MAIN                                                                  01/05/2020 18:55:34 PAGE 8   

 427   2                      /*      
 428   2                      sendDat[0] = (tempMinute /10) +0x30;
 429   2                      sendDat[1] = (tempMinute %10) +0x30;
 430   2                      sendDat[2] = 0x3A;  // 0x3A为结束标志位
 431   2                      */      
 432   2              }       
 433   1      }
 434          // 从问题中获得年份
 435          unsigned int getYearFromQuestion(unsigned char *point)
 436          {
 437   1              // 因为年份就是前4位
 438   1              unsigned char i=0,temp=0;
 439   1              unsigned int yearGo=0;
 440   1              while(i<4)
 441   1              {
 442   2                      temp = *point - 0x30;
 443   2                      yearGo *= 10;
 444   2                      yearGo += temp;
 445   2                      i++;
 446   2                      point++;                        
 447   2              }
 448   1              return yearGo;  
 449   1      }
 450          // 发送发送缓冲区的内容
 451          void sendData(unsigned char *point)
 452          {
 453   1              unsigned char i;
 454   1              unsigned char *temp = point;
 455   1              // 因为发送缓冲区的数据是以 0x3A 来作为截止
 456   1              while(*point != 0x3A)
 457   1              {
 458   2                      SBUF = *point;
 459   2                      while(!TI);   // 当正在发送的时候等待 ,TI == 1 表示发送完成
 460   2                      TI = 0;
 461   2                      point++;
 462   2              }
 463   1              // 清除发送缓冲区
 464   1              for(i=0;i<16;i++)
 465   1              {
 466   2                      temp[i] = 0x00;
 467   2              }               
 468   1      }
 469          // 从月份中获得工作日有几天
 470          unsigned char getWorkDayFromMonth(unsigned int yearGo,unsigned char monthGo)
 471          {
 472   1              // 注意年份都应该用 int 型，否则会溢出
 473   1              unsigned char tempWeek=0,tempDay=0;
 474   1              char workDay = 0;
 475   1              // 先获取该月的 1日是星期几
 476   1              tempWeek = getWeek(yearGo,monthGo,1);
 477   1              if(tempWeek == 0) tempWeek = 7;
 478   1              // 再获取该月一共有几天
 479   1              tempDay =  getMonthDay(yearGo,monthGo);
 480   1              // 计算工作日
 481   1              workDay += (6-tempWeek);
 482   1              if(workDay == -1) workDay = 0;
 483   1              // 计算剩余的天数
 484   1              tempDay -= (8 - tempWeek);
 485   1              // 计算剩余天数中的工作日
 486   1              workDay += (tempDay/7)*5; 
 487   1              tempDay = tempDay %7;
 488   1              if(tempDay >5) tempDay = 5;
C51 COMPILER V9.01   MAIN                                                                  01/05/2020 18:55:34 PAGE 9   

 489   1              workDay += tempDay;
 490   1      
 491   1              return workDay;
 492   1      }
 493          // 设置定时闹钟
 494          void setAlarmClock(unsigned int yearGo,unsigned char monthGo,unsigned char dayGo,unsigned char hourGo,unsi
             -gned char minuteGo)
 495          {
 496   1              alarmYear = yearGo;
 497   1              alarmMonth = monthGo;
 498   1              alarmDay = dayGo;
 499   1              alarmHour = hourGo;
 500   1              alarmMinute = minuteGo;
 501   1              alarmFlag = 1; // 开启闹钟
 502   1              // 通过串口会应，告诉设置好了
 503   1              // 回答 it's-ok
 504   1              sendDat[0] = 0x49; 
 505   1              sendDat[1] = 0x74;
 506   1              sendDat[2] = 0x60;
 507   1              sendDat[3] = 0x73;
 508   1              sendDat[4] = 0x2d;
 509   1              sendDat[5] = 0x6f;
 510   1              sendDat[6] = 0x6b;
 511   1              sendDat[7] = 0x0D;
 512   1              sendDat[8] = 0x0A; // 回车
 513   1              sendDat[9] = 0x3A; // 结束标志                  
 514   1      }
 515          // 用在updateTime中，用来检测当前时间是否达到预设的时间,达到则蜂鸣器响
 516          // 为了不要1秒检测一次，我们将这个放在60秒进位的时候检测一次
 517          void checkAlarmTime()
 518          {
 519   1              if((alarmMinute == minute) && (alarmHour == hour))
 520   1              {
 521   2                      if((alarmMonth == month) && (alarmDay == day))
 522   2                      {
 523   3                              if(alarmYear == year)
 524   3                              {
 525   4                                      buzzer_open();  
 526   4                              }
 527   3                      }       
 528   2              }
 529   1              else
 530   1              {
 531   2                      buzzer_close();
 532   2                      alarmFlag = 0; // 关闭闹钟
 533   2              }
 534   1      }
 535          // 测试用的将数据缓冲区内的所有内容发送出去
 536          void sendAllSDAT()
 537          {
 538   1              unsigned char i=0;
 539   1              for(i=0;i<64;i++)
 540   1              {
 541   2                      SBUF = sdat[i];
 542   2                      while(!TI);
 543   2                      TI = 0;
 544   2              }
 545   1      }
 546          
*** WARNING C290 IN LINE 16 OF MAIN.C: missing return value


C51 COMPILER V9.01   MAIN                                                                  01/05/2020 18:55:34 PAGE 10  

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2792    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    146      65
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
